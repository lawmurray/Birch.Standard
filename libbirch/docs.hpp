/**
 * @file
 *
 * Doxygen documentation.
 *
 * @mainpage
 *
 * LibBirch is a platform for probabilistic programming languages (PPLs),
 * intended as a compile target. It provides functionality such as smart
 * pointers and memory management for lazy deep copying (copy-on-write) of
 * objects, and so maximize object sharing. This is particularly important
 * for memory efficiency in PPLs using Sequential Monte Carlo (SMC) and
 * related methods for inference.
 *
 * LibBirch supports C++ code generated by the compiler for the Birch PPL
 * (https://birch-lang.org).
 *
 * @section copy_move_assign Construct, copy, move, assign
 *
 * The lazy deep copy mechanism provided by LibBirch requires that a
 * <i>current context</i> is provided upon object construction and assignment
 * for correct bookkeeping. Consequently, it is necessary to thread this as
 * an argument through any functions that may construct or assign objects.
 *
 * Constructors have an additional context argument:
 *
 *     A(Label* context, Args... args);
 *
 * The exception is the default constructor, which is always valid, as
 * pointers to objects default construct to `nullptr`, for which no context
 * is required:
 *
 *     A();
 *
 * The ordinary copy and move constructors of C++ should be used only for
 * implicit type conversion:
 *
 *     A(const A& o);
 *     A(A&& o);
 *
 * When explicitly constructing an object as a copy of another, use the
 * overloads with the additional context argument:
 *
 *     A(Label* context, const A& o);
 *     A(Label* context, A&& o);
 *
 * Internally, the lazy copy of an object invokes yet another copy
 * constructor, although it is never necessary to call this directly:
 *
 *     A(Label* context, Label* label, const A& o);
 *
 * Similarly, copy and move assignment operators of C++ are deleted and
 * replaced with assignment functions that accept an additional context
 * argument:
 *
 *     A& assign(Label* context, const A& o);
 *     A& assign(Label* context, A&& o);
 */
